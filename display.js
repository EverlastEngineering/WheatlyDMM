/*
This script takes the values from the JSON object generated by ble.js
and puts them in the elements of a page. This page is very basic. You might
want to do something more with it.

created 6 Aug 2018
by Tom Igoe

SVG interface and subsequent functions-

Nov 2022
by Jason Copp
*/

let value = "";
let units = "";

function fillDisplay(thisMeter) {
  // Is the meter connected or not?
  if (thisMeter.status !== null) {
    document.getElementById('status').value = thisMeter.status;
  } else {
    document.getElementById('status').value = 'Connected';
  }
  // assemble the meter reading's value, units, and order of magnitude:
  value = thisMeter.negativePolarity + thisMeter.value;
  if (thisMeter.negativePolarity == '') {
    document.getElementById('value').innerHTML = '<span style="opacity: 0">-</span>' + thisMeter.value;
  }
  else {
    document.getElementById('value').value = thisMeter.negativePolarity + thisMeter.value;
  }

  document.getElementById('units').value = units = thisMeter.magnitude
    + thisMeter.units;
  // IF measuring voltage or amperage, indicate AC/DC:
  if (thisMeter.units === 'volts' || thisMeter.units === 'amps') {
    document.getElementById('acDc').value = thisMeter.acDc;
  } else {
    // document.getElementById('acDc').value = '';
  }
  // if measuring non-contact voltage, indicate that, and clear units:
  if (thisMeter.ncv) {
    document.getElementById('value').value = thisMeter.ncv;
    document.getElementById('units').value = '';
  }
  // is auto-ranging on?
  if (thisMeter.autoRange) {
    // document.getElementById('autoRange').value = 'AutoRange';
  } else {
    document.getElementById('autoRange').value = '';
  }
  // is the hold button on?
  if (thisMeter.hold) {
    document.getElementById('hold').value = 'hold';
  } else {
    // document.getElementById('hold').value = '';
  }
  // what setting are you on?
  // document.getElementById('setting').value = thisMeter.setting;
  // data = data.slice(1);
  // data.push(parseFloat(value))
  // mainChart.data.datasets[0].data = data;
  // mainChart.data.datasets[0].label = units;
  // mainChart.update('none');
  meterValueHasUpdated = true;
}

// clear all the display elements except the connection status:
function clearDisplay(meter) {
  document.getElementById('connected').value = 'Disconnected';
  document.getElementById('value').value = '';
  document.getElementById('units').value = '';
  document.getElementById('acDc').value = '';
  document.getElementById('autoRange').value = '';
  document.getElementById('hold').value = '';
  document.getElementById('setting').value = '';
}

document.addEventListener('DOMContentLoaded', (function () {
  // wait for the svg to finish loading
  setTimeout(initializeInterface, 100)
}))

const graphSpeedMaximum = 1023;
const graphKnobResponsivenessFactor = 3
let graphSpeed = 903;
let graphUpdateDelay=420;

let meterValueHasUpdated = false;
let graphLastPlottedValue = 0;

let graphKnobPerimeter
let graphKnobHitBox
let graphKnobShadow
let graphButton
let graphButtonShadow
let graphSpeedKnobClicked = false;
let graphSpeedIndicator
let graphSpeedValueElement
let initialGraphSpeed;
let graphSpeedKnobPreviousRotation = 0
let mousePosition = {}
let mousePositionDelta = {}
let graphInterval=0;
let graphEnabled=false;

function startGraphAnimationInterval() {
  setInterval(() => {
    if (!graphEnabled) return
    let timeSinceLastUpdate = Date.now() - graphInterval;
    let stepsPerSec = 50;
    let stepsPerMin = 60;
    let maxMinutes = 60
    let maxTimeFactor = stepsPerSec + stepsPerMin + maxMinutes - 3 // 3 is the number of blocks
    let rounded = maxTimeFactor-Math.round(graphSpeed/graphSpeedMaximum*maxTimeFactor)+1

    if (rounded < stepsPerSec) {
      graphUpdateDelay = ((rounded) * (1000/stepsPerSec)) //+ (1000/30)
    }
    else if (rounded < stepsPerSec + stepsPerMin - 1)
    {
      graphUpdateDelay = (rounded-(stepsPerSec-1)) * 1000
    }
    else {
       graphUpdateDelay = (rounded-(stepsPerSec + stepsPerMin - 2)) * 1000 * 60
     }
    let graphShouldUpdate = (timeSinceLastUpdate > graphUpdateDelay)
    
    if (graphShouldUpdate) {
      data = data.slice(1);
      if (meterValueHasUpdated) {
        meterValueHasUpdated = false;
        graphLastPlottedValue = parseFloat(value)
      }
      data.push(parseFloat(graphLastPlottedValue));
      mainChart.data.datasets[0].data = data;
      mainChart.data.datasets[0].label = units;
      mainChart.update('none');
      graphInterval = Date.now()
    }
  }, 1000/30);
}

function initializeInterface() {
  graphButton = document.getElementById('gbutton')
  graphButtonShadow = document.getElementById('gbuttonshadow')

  graphKnobPerimeter = document.getElementById('knob')
  graphKnobPerimeter.setAttribute("transform-origin", "494.5 135.7")

  graphKnobShadow = document.getElementById('knobshadow')
  graphKnobShadow.setAttribute("transform-origin", "490.7 144.05")
  
  graphKnobHitBox = document.getElementById('knobhitbox')
  
  graphSpeedValueElement = document.getElementById('graph-speed-value')
  graphMessage()
  startGraphAnimationInterval()

  //listeners
  graphButton.addEventListener('mousedown', graphButtonAction)
  function graphButtonAction(event) {
    graphEnabled = !graphEnabled
    graphButtonShadow.style.opacity = (graphButtonShadow.style.opacity == 0.3)?0:0.3
    graphMessage()
  }
  
  graphKnobHitBox.addEventListener('touchstart',graphKnobHitBoxAction)
  graphKnobHitBox.addEventListener('mousedown',graphKnobHitBoxAction)
  function graphKnobHitBoxAction(event) {
    graphSpeedKnobClicked = true;
    if (event.preventDefault)
      event.preventDefault();
    
    mousePosition = {
      x: pointer(event).clientX,
      y: pointer(event).clientY
    }
    initialGraphSpeed = graphSpeed;
    graphSpeedKnobPreviousRotation = 0;
  }
  
  document.addEventListener('mouseup', (event) => {
    if (graphSpeedKnobClicked) {
      graphSpeedKnobClicked = false;
    }
  })

  document.addEventListener('mousemove', documentMoveAction)
  document.addEventListener('touchmove', documentMoveAction)
  function documentMoveAction(event) {
    if (graphSpeedKnobClicked) {
      mousePositionDelta = {
        x: pointer(event).clientX - mousePosition.x,
        y: pointer(event).clientY - mousePosition.y
      };
      turnGraphSpeedKnob(mousePositionDelta.y);
    }
  }
}

function turnGraphSpeedKnob(_rotation) {

  graphKnobPerimeter.setAttribute("transform", "rotate(" + _rotation + ")")
  graphKnobShadow.setAttribute("transform", "rotate(" + _rotation + ")")

  if (!graphEnabled) return
  
  let rotationValueIncreasing = false
  let rotationValueDecreasing = false

  if (_rotation > graphSpeedKnobPreviousRotation) {
    rotationValueIncreasing = true;
  }
  else if (_rotation < graphSpeedKnobPreviousRotation) {
    rotationValueDecreasing = true;
  }

  graphSpeed = initialGraphSpeed + _rotation * graphKnobResponsivenessFactor;

  if (graphSpeed < 0) {
    if (rotationValueIncreasing) {
      // if you go past the minimum, then increase, this causes the value to immediately start increasing instead of waiting to return to the 0 position
      initialGraphSpeed = initialGraphSpeed - graphSpeed
    }
    graphSpeed = 0
  }
  else if (graphSpeed > graphSpeedMaximum) {
    if (rotationValueDecreasing) {
      // if you go past the maximum, then decrease, this causes the value to immediately start decreasing instead of waiting to return to the 0 position
      initialGraphSpeed = (graphSpeedMaximum - _rotation * graphKnobResponsivenessFactor)
    }
    graphSpeed = graphSpeedMaximum
  }

  graphSpeedKnobPreviousRotation = _rotation;
  graphMessage()
}

function graphMessage() {
  if (!graphEnabled) {
      graphSpeedValueElement.innerHTML = "<br>!GRAPH!OFF!"
      return;
  }

  let displayLineOne = ''
  let displayLineTwo = ''
  
  if (graphSpeed == 0) {
    displayLineOne = '!!MINIMUM'
  }
  else if (graphSpeed == 1023) {
    displayLineOne = '--MAXIMUM--'
  }
  else {
    let numOfChars = Math.ceil(graphSpeed / ((graphSpeedMaximum - 1) / 10))
    for (let i = 0; i < numOfChars; i++) {
      displayLineOne = displayLineOne + '-'
    }
  }

  if (graphUpdateDelay > 60000) {
    displayLineTwo = "" + graphUpdateDelay/1000/60 + "!MINUTES!"
  }
  else if (graphUpdateDelay == 60000) {
    displayLineTwo = "" + graphUpdateDelay/1000/60 + "!MINUTE!!"
  }
  else if (graphUpdateDelay > 1000) {
    displayLineTwo = "" + graphUpdateDelay/1000 + "!SECONDS!"
  }
  else if (graphUpdateDelay == 1000) {
    displayLineTwo = "" + graphUpdateDelay/1000 + "!SECOND!!"
  }
  else {
    displayLineTwo = Math.round(graphUpdateDelay) + "!MS!!!";
  }

  // this is for right justification
  for (let i = displayLineTwo.length;i<11;i++)
  {
    displayLineTwo = "!" + displayLineTwo;
  }
  
  graphSpeedValueElement.innerHTML = displayLineOne + "<br>" + displayLineTwo
}

function pointer(event) {
  // crude & handy to ignore diff between mouse and touch
  if (event.touches) {
    return event.touches[0]
  }
  else {
    return event
  }
}
