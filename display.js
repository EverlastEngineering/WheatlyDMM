/*
This script takes the values from the JSON object generated by ble.js
and puts them in the elements of a page. This page is very basic. You might
want to do something more with it.

created 6 Aug 2018
by Tom Igoe
*/

let value = "";
let units = "";

function fillDisplay(thisMeter) {
  // Is the meter connected or not?
  if (thisMeter.status !== null) {
    document.getElementById('status').value = thisMeter.status;
  } else {
    document.getElementById('status').value = 'Connected';
  }
  // assemble the meter reading's value, units, and order of magnitude:
  value = thisMeter.negativePolarity + thisMeter.value;
  if (thisMeter.negativePolarity == '') {
    document.getElementById('value').innerHTML = '<span style="opacity: 0">-</span>' + thisMeter.value;
  }
  else {
    document.getElementById('value').value = thisMeter.negativePolarity + thisMeter.value;
  }

  document.getElementById('units').value = units = thisMeter.magnitude
    + thisMeter.units;
  // IF measuring voltage or amperage, indicate AC/DC:
  if (thisMeter.units === 'volts' || thisMeter.units === 'amps') {
    document.getElementById('acDc').value = thisMeter.acDc;
  } else {
    // document.getElementById('acDc').value = '';
  }
  // if measuring non-contact voltage, indicate that, and clear units:
  if (thisMeter.ncv) {
    document.getElementById('value').value = thisMeter.ncv;
    document.getElementById('units').value = '';
  }
  // is auto-ranging on?
  if (thisMeter.autoRange) {
    // document.getElementById('autoRange').value = 'AutoRange';
  } else {
    document.getElementById('autoRange').value = '';
  }
  // is the hold button on?
  if (thisMeter.hold) {
    document.getElementById('hold').value = 'hold';
  } else {
    // document.getElementById('hold').value = '';
  }
  // what setting are you on?
  // document.getElementById('setting').value = thisMeter.setting;
  // data = data.slice(1);
  // data.push(parseFloat(value))
  // mainChart.data.datasets[0].data = data;
  // mainChart.data.datasets[0].label = units;
  // mainChart.update('none');
  valueUpdated = true;
}

// clear all the display elements except the connection status:
function clearDisplay(meter) {
  document.getElementById('connected').value = 'Disconnected';
  document.getElementById('value').value = '';
  document.getElementById('units').value = '';
  document.getElementById('acDc').value = '';
  document.getElementById('autoRange').value = '';
  document.getElementById('hold').value = '';
  document.getElementById('setting').value = '';
}
let valueUpdated = false;
let lastValue = 0;
let graphSlowestSpeed = 10000;

const graphSpeedMaximum = 1023;
const graphKnobResponsivenessFactor = 8

let graphKnobPerimeter
let graphKnobHitBox
let graphKnobShadow
let graphButton
let graphButtonShadow
let graphSpeedKnobClicked = false;
let graphSpeedIndicator
let graphSpeedValueElement

let graphSpeed = 783;
let initialGraphSpeed;
let graphSpeedKnobPreviousRotation = 0
let mousePosition = {}
let mousePositionDelta = {}
let graphInterval=0;
let graphUpdateDelay=66.6666;
let graphEnabled=false;


let iv2;
function enableGraphAnimation() {
  setInterval(() => {
    if (!graphEnabled) return
    let timeSinceLastUpdate = Date.now() - graphInterval;
    graphUpdateDelay = 49/(Math.pow(((graphSpeed+150)/(graphSpeedMaximum+10)),3)) //magic!!
    let graphShouldUpdate = (timeSinceLastUpdate > graphUpdateDelay)
    
    if (graphShouldUpdate) {
      data = data.slice(1);
      if (valueUpdated) {
        valueUpdated = false;
        lastValue = parseFloat(value)
      }
      data.push(parseFloat(lastValue));
      mainChart.data.datasets[0].data = data;
      mainChart.data.datasets[0].label = units;
      mainChart.update('none');
      graphInterval = Date.now()
    }
  }, 1000/30);
}

function go() {
  graphButton = document.getElementById('gbutton')
  graphButtonShadow = document.getElementById('gbuttonshadow')

  graphKnobPerimeter = document.getElementById('knob')
  graphKnobShadow = document.getElementById('knobshadow')
  graphKnobHitBox = document.getElementById('knobhitbox')
  graphSpeedValueElement = document.getElementById('graph-speed-value')
  graphMessage()
  enableGraphAnimation()

graphButton.addEventListener('mousedown', (event) => {
  graphEnabled = !graphEnabled
  graphButtonShadow.style.opacity = (graphButtonShadow.style.opacity == 0.3)?0:0.3
  graphMessage()
})

  graphKnobPerimeter.setAttribute("transform-origin", "494.5 135.7")
  graphKnobShadow.setAttribute("transform-origin", "490.7 144.05")

  graphKnobHitBox.addEventListener('mousedown', (event) => {
    graphSpeedKnobClicked = true;
    if (event.preventDefault)
      event.preventDefault();
    mousePosition = {
      x: event.clientX,
      y: event.clientY
    };
    initialGraphSpeed = graphSpeed;
    graphSpeedKnobPreviousRotation = 0;
  })

  document.addEventListener('mouseup', (event) => {
    if (graphSpeedKnobClicked) {
      console.log('mouseup. graphspeed = ' + graphSpeed);
      graphSpeedKnobClicked = false;
    }
  })

  document.addEventListener('mousemove', (event) => {
    if (graphSpeedKnobClicked) {
      mousePositionDelta = {
        x: event.clientX - mousePosition.x,
        y: event.clientY - mousePosition.y
      };
      turn(mousePositionDelta.y);
    }
  })
}

function turn(_rotation) {
  
  graphKnobPerimeter.setAttribute("transform", "rotate(" + _rotation + ")")
  graphKnobShadow.setAttribute("transform", "rotate(" + _rotation + ")")

  if (!graphEnabled) return
  
  let rotationValueIncreasing = false
  let rotationValueDecreasing = false

  if (_rotation > graphSpeedKnobPreviousRotation) {
    rotationValueIncreasing = true;
  }
  else if (_rotation < graphSpeedKnobPreviousRotation) {
    rotationValueDecreasing = true;
  }

  graphSpeed = initialGraphSpeed + _rotation * graphKnobResponsivenessFactor;

  if (graphSpeed < 0) {
    if (rotationValueIncreasing) {
      // if you go past the minimum, then increase, this causes the value to immediately start increasing instead of waiting to return to the 0 position
      initialGraphSpeed = initialGraphSpeed - graphSpeed
    }
    graphSpeed = 0
  }
  else if (graphSpeed > graphSpeedMaximum) {
    if (rotationValueDecreasing) {
      // if you go past the maximum, then decrease, this causes the value to immediately start decreasing instead of waiting to return to the 0 position
      initialGraphSpeed = (graphSpeedMaximum - _rotation * graphKnobResponsivenessFactor)
    }
    graphSpeed = graphSpeedMaximum
  }

  graphSpeedKnobPreviousRotation = _rotation;
  updateGraphSpeedDisplay()
}

let timeout;

function updateGraphSpeedDisplay() {
  let innerHTML = '';
  graphMessage(innerHTML); return;
  if (graphSpeed == 0) {
    innerHTML = '!!MINIMUM'
  }
  else if (graphSpeed == 1023) {
    innerHTML = '--MAXIMUM--'
  }
  else {
    let numOfChars = Math.ceil(graphSpeed / ((graphSpeedMaximum - 1) / 10))
    for (let i = 0; i < numOfChars; i++) {
      innerHTML = innerHTML + '-'
    }
  }
  graphSpeedValueElement.innerHTML = innerHTML
  clearTimeout(timeout)
  timeout = setTimeout(graphMessage,2000,innerHTML);
  
}

function graphMessage(innerHTML) {
  if (innerHTML == undefined) innerHTML = ''
  let updatesPerSecond = 1000 / graphUpdateDelay;
  if (!graphEnabled) {
    innerHTML = "!GRAPH!OFF!"
  }
  else if (updatesPerSecond < 1) {
    innerHTML = Math.round(1000 / graphUpdateDelay * 60) + "!PER!MIN";
  }
  else {
    innerHTML = Math.round(1000 / graphUpdateDelay * 1) / 1 + "!PER!SEC";
  }
  
  for (let i = innerHTML.length;i<11;i++)
    {
      innerHTML = "!" + innerHTML;
      // console.log(i)
      // let a = 1;
    }
  
  graphSpeedValueElement.innerHTML = innerHTML
}

document.addEventListener('DOMContentLoaded', (function () {
  // wait for the svg to finish loading
  setTimeout(go, 100)
}))

